// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: favorite.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addFavourite = `-- name: AddFavourite :exec
INSERT INTO favorite (id, property_id, tenant_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type AddFavouriteParams struct {
	ID         uuid.UUID
	PropertyID uuid.UUID
	TenantID   uuid.UUID
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) AddFavourite(ctx context.Context, arg AddFavouriteParams) error {
	_, err := q.db.ExecContext(ctx, addFavourite,
		arg.ID,
		arg.PropertyID,
		arg.TenantID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getFavourite = `-- name: GetFavourite :one
SELECT id, property_id, tenant_id, created_at, updated_at FROM favorite WHERE property_id = $1 AND tenant_id = $2
`

type GetFavouriteParams struct {
	PropertyID uuid.UUID
	TenantID   uuid.UUID
}

func (q *Queries) GetFavourite(ctx context.Context, arg GetFavouriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, getFavourite, arg.PropertyID, arg.TenantID)
	var i Favorite
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFavouriteProperties = `-- name: GetFavouriteProperties :many
SELECT 
  f.id AS favorite_id,
  f.tenant_id,
  p.id AS property_id,
  p.name AS property_name,
  p.description AS property_description,
  p.price_per_month,
  p.security_deposit,
  p.application_fee,
  p.photo_urls,
  p.is_pets_allowed,
  p.is_parking_included,
  p.manager_id AS property_manager_id,
  p.tenant_id AS property_tenant_id,
  p.beds,
  p.baths,
  p.square_feet,
  p.property_type,
  p.average_rating,
  p.number_of_reviews,
  p.created_at AS property_created_at,
  p.updated_at AS property_updated_at,
  loc.id AS location_id,
  loc.address,
  loc.city,
  loc.state,
  loc.country,
  loc.postal_code,
  ST_X(loc.coordinates::geometry) AS longitude, 
  ST_Y(loc.coordinates::geometry) AS latitude
FROM 
  favorite f
JOIN property p ON f.property_id = p.id
JOIN location loc ON p.location_id = loc.id
WHERE f.tenant_id = $1
`

type GetFavouritePropertiesRow struct {
	FavoriteID          uuid.UUID
	TenantID            uuid.UUID
	PropertyID          uuid.UUID
	PropertyName        string
	PropertyDescription string
	PricePerMonth       string
	SecurityDeposit     string
	ApplicationFee      string
	PhotoUrls           []string
	IsPetsAllowed       bool
	IsParkingIncluded   bool
	PropertyManagerID   uuid.UUID
	PropertyTenantID    uuid.NullUUID
	Beds                int32
	Baths               string
	SquareFeet          int32
	PropertyType        PropertyType
	AverageRating       sql.NullString
	NumberOfReviews     sql.NullInt32
	PropertyCreatedAt   time.Time
	PropertyUpdatedAt   time.Time
	LocationID          uuid.UUID
	Address             string
	City                string
	State               string
	Country             string
	PostalCode          string
	Longitude           interface{}
	Latitude            interface{}
}

func (q *Queries) GetFavouriteProperties(ctx context.Context, tenantID uuid.UUID) ([]GetFavouritePropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFavouriteProperties, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavouritePropertiesRow
	for rows.Next() {
		var i GetFavouritePropertiesRow
		if err := rows.Scan(
			&i.FavoriteID,
			&i.TenantID,
			&i.PropertyID,
			&i.PropertyName,
			&i.PropertyDescription,
			&i.PricePerMonth,
			&i.SecurityDeposit,
			&i.ApplicationFee,
			pq.Array(&i.PhotoUrls),
			&i.IsPetsAllowed,
			&i.IsParkingIncluded,
			&i.PropertyManagerID,
			&i.PropertyTenantID,
			&i.Beds,
			&i.Baths,
			&i.SquareFeet,
			&i.PropertyType,
			&i.AverageRating,
			&i.NumberOfReviews,
			&i.PropertyCreatedAt,
			&i.PropertyUpdatedAt,
			&i.LocationID,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.Longitude,
			&i.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavourite = `-- name: RemoveFavourite :exec
DELETE FROM favorite WHERE id = $1 AND property_id = $2 AND tenant_id = $3
`

type RemoveFavouriteParams struct {
	ID         uuid.UUID
	PropertyID uuid.UUID
	TenantID   uuid.UUID
}

func (q *Queries) RemoveFavourite(ctx context.Context, arg RemoveFavouriteParams) error {
	_, err := q.db.ExecContext(ctx, removeFavourite, arg.ID, arg.PropertyID, arg.TenantID)
	return err
}
