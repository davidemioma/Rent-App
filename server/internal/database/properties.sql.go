// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: properties.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getFilteredProperties = `-- name: GetFilteredProperties :many
SELECT 
  p.id, p.name, p.description, p.price_per_month, p.security_deposit, p.application_fee, p.photo_urls, p.is_pets_allowed, p.is_parking_included, p.beds, p.baths, p.square_feet, p.property_type, p.average_rating, p.number_of_reviews, p.location_id, p.manager_id, p.created_at, p.updated_at,
  json_build_object(
    'id', l.id,
    'address', l.address,
    'city', l.city,
    'state', l.state,
    'country', l.country,
    'postal_code', l.postal_code,
    'coordinates', json_build_object(
      'longitude', ST_X(l.coordinates::geometry),
      'latitude', ST_Y(l.coordinates::geometry)
    )
  ) as location
FROM property p
JOIN location l ON p.location_id = l.id
WHERE 
  (CAST($1 AS uuid[]) IS NULL OR p.id = ANY(CAST($1 AS uuid[])))
  AND (CAST($2 AS numeric) IS NULL OR p.price_per_month >= CAST($2 AS numeric))
  AND (CAST($3 AS numeric) IS NULL OR p.price_per_month <= CAST($3 AS numeric))
  AND (CAST($4 AS int) IS NULL OR $4 = 'any' OR p.beds >= CAST($4 AS int))
  AND (CAST($5 AS int) IS NULL OR $5 = 'any' OR p.baths >= CAST($5 AS int))
  AND (CAST($6 AS int) IS NULL OR p.square_feet >= CAST($6 AS int))
  AND (CAST($7 AS int) IS NULL OR p.square_feet <= CAST($7 AS int))
  AND (
    $8 IS NULL OR 
    $8 = 'any' OR 
    p.property_type = CAST($8 AS property_type)
  )
  AND (array_length($9::text[], 1) IS NULL OR $9 = '{"any"}' OR p.amenities @> CAST($9 AS text[]))
  AND (
    CAST($10 AS timestamp) IS NULL OR 
    $10 = 'any' OR
    EXISTS (
      SELECT 1 FROM lease le 
      WHERE le.property_id = p.id 
      AND le.start_date <= CAST($10 AS timestamp)
    )
  )
  AND (
    CAST($11 AS float) IS NULL OR 
    CAST($12 AS float) IS NULL OR
    ST_DWithin(
      l.coordinates::geometry,
      ST_SetSRID(ST_MakePoint(CAST($12 AS float), CAST($11 AS float)), 4326),
      1000 / 111.0
    )
  )
`

type GetFilteredPropertiesParams struct {
	FavoriteIds   []uuid.UUID
	PriceMin      string
	PriceMax      string
	Beds          int32
	Baths         int32
	SquareFeetMin int32
	SquareFeetMax int32
	PropertyType  interface{}
	Amenities     []string
	AvailableFrom time.Time
	Latitude      float64
	Longitude     float64
}

type GetFilteredPropertiesRow struct {
	ID                uuid.UUID
	Name              string
	Description       string
	PricePerMonth     string
	SecurityDeposit   string
	ApplicationFee    string
	PhotoUrls         []string
	IsPetsAllowed     bool
	IsParkingIncluded bool
	Beds              int32
	Baths             string
	SquareFeet        int32
	PropertyType      PropertyType
	AverageRating     sql.NullString
	NumberOfReviews   sql.NullInt32
	LocationID        uuid.UUID
	ManagerID         uuid.UUID
	CreatedAt         time.Time
	UpdatedAt         time.Time
	Location          json.RawMessage
}

func (q *Queries) GetFilteredProperties(ctx context.Context, arg GetFilteredPropertiesParams) ([]GetFilteredPropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredProperties,
		pq.Array(arg.FavoriteIds),
		arg.PriceMin,
		arg.PriceMax,
		arg.Beds,
		arg.Baths,
		arg.SquareFeetMin,
		arg.SquareFeetMax,
		arg.PropertyType,
		pq.Array(arg.Amenities),
		arg.AvailableFrom,
		arg.Latitude,
		arg.Longitude,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredPropertiesRow
	for rows.Next() {
		var i GetFilteredPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PricePerMonth,
			&i.SecurityDeposit,
			&i.ApplicationFee,
			pq.Array(&i.PhotoUrls),
			&i.IsPetsAllowed,
			&i.IsParkingIncluded,
			&i.Beds,
			&i.Baths,
			&i.SquareFeet,
			&i.PropertyType,
			&i.AverageRating,
			&i.NumberOfReviews,
			&i.LocationID,
			&i.ManagerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationCoordinates = `-- name: GetLocationCoordinates :one
SELECT 
    ST_X(coordinates) AS longitude,  -- float64
    ST_Y(coordinates) AS latitude    -- float64
FROM location 
WHERE id = $1
`

type GetLocationCoordinatesRow struct {
	Longitude interface{}
	Latitude  interface{}
}

func (q *Queries) GetLocationCoordinates(ctx context.Context, id uuid.UUID) (GetLocationCoordinatesRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationCoordinates, id)
	var i GetLocationCoordinatesRow
	err := row.Scan(&i.Longitude, &i.Latitude)
	return i, err
}

const getProperty = `-- name: GetProperty :one
SELECT p.id, p.name, p.description, p.price_per_month, p.security_deposit, p.application_fee, p.photo_urls, p.is_pets_allowed, p.is_parking_included, p.beds, p.baths, p.square_feet, p.property_type, p.average_rating, p.number_of_reviews, p.location_id, p.manager_id, p.created_at, p.updated_at, l.id, l.address, l.city, l.state, l.country, l.postal_code, l.coordinates
FROM property p
LEFT JOIN location l ON p.location_id = l.id
WHERE p.id = $1
`

type GetPropertyRow struct {
	ID                uuid.UUID
	Name              string
	Description       string
	PricePerMonth     string
	SecurityDeposit   string
	ApplicationFee    string
	PhotoUrls         []string
	IsPetsAllowed     bool
	IsParkingIncluded bool
	Beds              int32
	Baths             string
	SquareFeet        int32
	PropertyType      PropertyType
	AverageRating     sql.NullString
	NumberOfReviews   sql.NullInt32
	LocationID        uuid.UUID
	ManagerID         uuid.UUID
	CreatedAt         time.Time
	UpdatedAt         time.Time
	ID_2              uuid.NullUUID
	Address           sql.NullString
	City              sql.NullString
	State             sql.NullString
	Country           sql.NullString
	PostalCode        sql.NullString
	Coordinates       interface{}
}

func (q *Queries) GetProperty(ctx context.Context, id uuid.UUID) (GetPropertyRow, error) {
	row := q.db.QueryRowContext(ctx, getProperty, id)
	var i GetPropertyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PricePerMonth,
		&i.SecurityDeposit,
		&i.ApplicationFee,
		pq.Array(&i.PhotoUrls),
		&i.IsPetsAllowed,
		&i.IsParkingIncluded,
		&i.Beds,
		&i.Baths,
		&i.SquareFeet,
		&i.PropertyType,
		&i.AverageRating,
		&i.NumberOfReviews,
		&i.LocationID,
		&i.ManagerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.Coordinates,
	)
	return i, err
}
